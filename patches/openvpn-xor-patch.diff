diff -uNr openvpn.orig/configure.ac openvpn/configure.ac
--- openvpn.orig/configure.ac	2023-02-22 23:44:49.000000000 +0800
+++ openvpn/configure.ac	2023-02-22 23:46:14.000000000 +0800
@@ -319,7 +319,21 @@
 		AC_DEFINE([TARGET_DARWIN], [1], [Are we running on Mac OS X?])
 		AC_DEFINE_UNQUOTED([TARGET_PREFIX], ["M"], [Target prefix])
 		have_tap_header="yes"
+		AC_CHECK_HEADER(
+			[IOKit/network/IOUserEthernetController.h],
+			[
+			 have_ioethernet_header="yes"
+			 AC_DEFINE([DARWIN_IOKIT_FULL_PATH], [1], [Include <IOKit/network/IOUserEthernetController.h>])
+			],
+			[
+			  AC_CHECK_HEADER([IOUserEthernetController.h], [have_ioethernet_header="yes"], [], [])
+			],
+			[]
+		)
+		test "${have_ioethernet_header}" = "yes" || AC_MSG_ERROR([no IOUserEthernetController header could be found])
+
 		ac_cv_type_struct_in_pktinfo=no
+		LDFLAGS="${LDFLAGS} -framework CoreFoundation -framework IOKit -framework SystemConfiguration"
 		;;
 	*-mingw*)
 		AC_DEFINE([TARGET_WIN32], [1], [Are we running WIN32?])
diff -uNr openvpn.orig/src/openvpn/forward.c openvpn/src/openvpn/forward.c
--- openvpn.orig/src/openvpn/forward.c	2023-02-22 23:44:49.000000000 +0800
+++ openvpn/src/openvpn/forward.c	2023-02-22 23:45:32.000000000 +0800
@@ -811,7 +811,10 @@
 
     status = link_socket_read(c->c2.link_socket,
                               &c->c2.buf,
-                              &c->c2.from);
+			                  &c->c2.from,
+			                  c->options.ce.xormethod,
+			                  c->options.ce.xormask,
+			                  c->options.ce.xormasklen);
 
     if (socket_connection_reset(c->c2.link_socket, status))
     {
@@ -1621,7 +1624,10 @@
                 /* Send packet */
                 size = link_socket_write(c->c2.link_socket,
                                          &c->c2.to_link,
-                                         to_addr);
+                                         to_addr,
+                                         c->options.ce.xormethod,
+                                         c->options.ce.xormask,
+                                         c->options.ce.xormasklen);
 
                 /* Undo effect of prepend */
                 link_socket_write_post_size_adjust(&size, size_delta, &c->c2.to_link);
diff -uNr openvpn.orig/src/openvpn/init.c openvpn/src/openvpn/init.c
--- openvpn.orig/src/openvpn/init.c	2023-02-22 23:44:49.000000000 +0800
+++ openvpn/src/openvpn/init.c	2023-02-22 23:46:07.000000000 +0800
@@ -1512,6 +1512,7 @@
     if (init_route_list(route_list,
                         options->routes,
                         gw,
+                        options->route_gateway_via_dhcp,
                         metric,
                         link_socket_current_remote(link_socket_info),
                         es,
diff -uNr openvpn.orig/src/openvpn/options.c openvpn/src/openvpn/options.c
--- openvpn.orig/src/openvpn/options.c	2023-02-22 23:44:49.000000000 +0800
+++ openvpn/src/openvpn/options.c	2023-02-22 23:45:38.000000000 +0800
@@ -821,6 +821,9 @@
     o->resolve_retry_seconds = RESOLV_RETRY_INFINITE;
     o->resolve_in_advance = false;
     o->proto_force = -1;
+    o->ce.xormethod = 0;
+    o->ce.xormask = "\0";
+    o->ce.xormasklen = 0;
     o->occ = true;
 #ifdef ENABLE_MANAGEMENT
     o->management_log_history_cache = 250;
@@ -973,6 +976,9 @@
     setenv_str_i(es, "local_port", e->local_port, i);
     setenv_str_i(es, "remote", e->remote, i);
     setenv_str_i(es, "remote_port", e->remote_port, i);
+    setenv_int_i(es, "xormethod", e->xormethod, i);
+    setenv_str_i(es, "xormask", e->xormask, i);
+    setenv_int_i(es, "xormasklen", e->xormasklen, i);
 
     if (e->http_proxy_options)
     {
@@ -1508,6 +1514,9 @@
     SHOW_BOOL(bind_ipv6_only);
     SHOW_INT(connect_retry_seconds);
     SHOW_INT(connect_timeout);
+    SHOW_INT (xormethod);
+    SHOW_STR (xormask);
+    SHOW_INT (xormasklen);
 
     if (o->http_proxy_options)
     {
@@ -6318,6 +6327,46 @@
         }
         options->proto_force = proto_force;
     }
+    else if (streq (p[0], "scramble") && p[1])
+    {
+        VERIFY_PERMISSION (OPT_P_GENERAL|OPT_P_CONNECTION);
+        if (streq (p[1], "xormask") && p[2] && (!p[3]))
+        {
+            options->ce.xormethod = 1;
+            options->ce.xormask = p[2];
+            options->ce.xormasklen = strlen(options->ce.xormask);
+        }
+        else if (streq (p[1], "xorptrpos") && (!p[2]))
+        {
+            options->ce.xormethod = 2;
+            options->ce.xormask = NULL;
+            options->ce.xormasklen = 0;
+        }
+        else if (streq (p[1], "reverse") && (!p[2]))
+        {
+            options->ce.xormethod = 3;
+            options->ce.xormask = NULL;
+            options->ce.xormasklen = 0;
+        }
+        else if (streq (p[1], "obfuscate") && p[2] && (!p[3]))
+        {
+            options->ce.xormethod = 4;
+            options->ce.xormask = p[2];
+            options->ce.xormasklen = strlen(options->ce.xormask);
+        }
+        else if (!p[2])
+        {
+            msg (M_WARN, "WARNING: No recognized 'scramble' method specified; using 'scramble xormask \"%s\"'", p[1]);
+            options->ce.xormethod = 1;
+            options->ce.xormask = p[1];
+            options->ce.xormasklen = strlen(options->ce.xormask);
+        }
+        else
+        {
+            msg (msglevel, "No recognized 'scramble' method specified or extra parameters for 'scramble'");
+            goto err;
+        }
+    }
     else if (streq(p[0], "http-proxy") && p[1] && !p[5])
     {
         struct http_proxy_options *ho;
diff -uNr openvpn.orig/src/openvpn/options.h openvpn/src/openvpn/options.h
--- openvpn.orig/src/openvpn/options.h	2023-02-22 23:44:49.000000000 +0800
+++ openvpn/src/openvpn/options.h	2023-02-22 23:45:42.000000000 +0800
@@ -99,6 +99,9 @@
     int connect_retry_seconds;
     int connect_retry_seconds_max;
     int connect_timeout;
+    int xormethod;
+    const char *xormask;
+    int xormasklen;
     struct http_proxy_options *http_proxy_options;
     const char *socks_proxy_server;
     const char *socks_proxy_port;
diff -uNr openvpn.orig/src/openvpn/route.c openvpn/src/openvpn/route.c
--- openvpn.orig/src/openvpn/route.c	2023-02-22 23:44:49.000000000 +0800
+++ openvpn/src/openvpn/route.c	2023-02-22 23:46:07.000000000 +0800
@@ -297,6 +297,12 @@
 }
 
 static bool
+should_use_dhcp_gateway(const char *gateway, const struct route_list *rl)
+{
+    return (rl->spec.flags & RTSA_DHCP_ENDPOINT && (!is_route_parm_defined(gateway) || !strcmp(gateway, "vpn_gateway")));
+}
+
+static bool
 init_route(struct route_ipv4 *r,
            struct addrinfo **network_list,
            const struct route_option *ro,
@@ -363,7 +369,11 @@
 
     /* gateway */
 
-    if (is_route_parm_defined(ro->gateway))
+    if (should_use_dhcp_gateway(ro->gateway, rl))
+    {
+        r->flags |= RT_DHCP_GATEWAY;
+    }
+    else if (is_route_parm_defined(ro->gateway))
     {
         if (!get_special_addr(rl, ro->gateway, &r->gateway, &status))
         {
@@ -415,7 +425,10 @@
         r->flags |= RT_METRIC_DEFINED;
     }
 
-    r->flags |= RT_DEFINED;
+    if ((r->flags & RT_DHCP_GATEWAY) == 0)
+    {
+        r->flags |= RT_DEFINED;
+    }
 
     return true;
 
@@ -537,6 +550,16 @@
     rl->spec.remote_endpoint = addr;
     rl->spec.flags |= RTSA_REMOTE_ENDPOINT;
     setenv_route_addr(es, "vpn_gateway", rl->spec.remote_endpoint, -1);
+
+    struct route_ipv4 *r;
+    for (r = rl->routes; r; r = r->next)
+    {
+        if (r->flags & RT_DHCP_GATEWAY)
+        {
+            r->gateway = addr;
+            r->flags |= RT_DEFINED;
+        }
+    }
 }
 
 static void
@@ -607,6 +630,7 @@
 init_route_list(struct route_list *rl,
                 const struct route_option_list *opt,
                 const char *remote_endpoint,
+                bool remote_endpoint_dhcp,
                 int default_metric,
                 in_addr_t remote_host,
                 struct env_set *es,
@@ -673,6 +697,10 @@
             ret = false;
         }
     }
+    else if (remote_endpoint_dhcp)
+    {
+        rl->spec.flags |= RTSA_DHCP_ENDPOINT;
+    }
 
     if (rl->flags & RG_ENABLE)
     {
diff -uNr openvpn.orig/src/openvpn/route.h openvpn/src/openvpn/route.h
--- openvpn.orig/src/openvpn/route.h	2023-02-22 23:44:49.000000000 +0800
+++ openvpn/src/openvpn/route.h	2023-02-22 23:46:07.000000000 +0800
@@ -63,6 +63,7 @@
 #define RTSA_REMOTE_ENDPOINT  (1<<0)
 #define RTSA_REMOTE_HOST      (1<<1)
 #define RTSA_DEFAULT_METRIC   (1<<2)
+#define RTSA_DHCP_ENDPOINT    (1<<3)
     unsigned int flags;
 
     in_addr_t remote_endpoint;
@@ -113,6 +114,7 @@
 #define RT_DEFINED        (1<<0)
 #define RT_ADDED          (1<<1)
 #define RT_METRIC_DEFINED (1<<2)
+#define RT_DHCP_GATEWAY   (1<<3)
     struct route_ipv4 *next;
     unsigned int flags;
     const struct route_option *option;
@@ -286,6 +288,7 @@
 bool init_route_list(struct route_list *rl,
                      const struct route_option_list *opt,
                      const char *remote_endpoint,
+                     bool remote_endpoint_dhcp,
                      int default_metric,
                      in_addr_t remote_host,
                      struct env_set *es,
diff -uNr openvpn.orig/src/openvpn/socket.c openvpn/src/openvpn/socket.c
--- openvpn.orig/src/openvpn/socket.c	2023-02-22 23:44:49.000000000 +0800
+++ openvpn/src/openvpn/socket.c	2023-02-22 23:45:48.000000000 +0800
@@ -72,6 +72,56 @@
     }
 }
 
+int buffer_mask(struct buffer *buf, const char *mask, int xormasklen)
+{
+    int i;
+    uint8_t *b;
+    if (  xormasklen > 0  ) {
+        for (i = 0, b = BPTR (buf); i < BLEN(buf); i++, b++) {
+            *b = *b ^ mask[i % xormasklen];
+        }
+    }
+    return BLEN (buf);
+}
+
+int buffer_xorptrpos(struct buffer *buf)
+{
+    int i;
+    uint8_t *b;
+    for (i = 0, b = BPTR (buf); i < BLEN(buf); i++, b++) {
+        *b = *b ^ i+1;
+    }
+    return BLEN (buf);
+}
+
+int buffer_reverse(struct buffer *buf)
+{
+/* This function has been rewritten for Tunnelblick. The buffer_reverse function at
+ * https://github.com/clayface/openvpn_xorpatch
+ * makes a copy of the buffer and it writes to the byte **after** the
+ * buffer contents, so if the buffer is full then it writes outside of the buffer.
+ * This rewritten version does neither.
+ *
+ * For interoperability, this rewritten version preserves the behavior of the original
+ * function: it does not modify the first character of the buffer. So it does not
+ * actually reverse the contents of the buffer. Instead, it changes 'abcde' to 'aedcb'.
+ * (Of course, the actual buffer contents are bytes, and not necessarily characters.)
+ */
+    int len = BLEN(buf);
+    if (  len > 2  ) {                           /* Leave '', 'a', and 'ab' alone */
+        int i;
+        uint8_t *b_start = BPTR (buf) + 1;            /* point to first byte to swap */
+        uint8_t *b_end   = BPTR (buf) + (len - 1); /* point to last byte to swap */
+        uint8_t tmp;
+        for (i = 0; i < (len-1)/2; i++, b_start++, b_end--) {
+            tmp = *b_start;
+            *b_start = *b_end;
+            *b_end = tmp;
+        }
+    }
+    return len;
+}
+
 /*
  * Functions related to the translation of DNS names to IP addresses.
  */
diff -uNr openvpn.orig/src/openvpn/socket.h openvpn/src/openvpn/socket.h
--- openvpn.orig/src/openvpn/socket.h	2023-02-22 23:44:49.000000000 +0800
+++ openvpn/src/openvpn/socket.h	2023-02-22 23:45:55.000000000 +0800
@@ -249,6 +249,10 @@
 #endif
 };
 
+int buffer_mask(struct buffer *buf, const char *xormask, int xormasklen);
+int buffer_xorptrpos(struct buffer *buf);
+int buffer_reverse(struct buffer *buf);
+
 /*
  * Some Posix/Win32 differences.
  */
@@ -1049,30 +1053,57 @@
 static inline int
 link_socket_read(struct link_socket *sock,
                  struct buffer *buf,
-                 struct link_socket_actual *from)
+                 struct link_socket_actual *from,
+                 int xormethod,
+                 const char *xormask,
+                 int xormasklen)
 {
+    int res;
     if (proto_is_udp(sock->info.proto)) /* unified UDPv4 and UDPv6 */
     {
-        int res;
-
 #ifdef _WIN32
         res = link_socket_read_udp_win32(sock, buf, from);
 #else
         res = link_socket_read_udp_posix(sock, buf, from);
 #endif
-        return res;
     }
     else if (proto_is_tcp(sock->info.proto)) /* unified TCPv4 and TCPv6 */
     {
         /* from address was returned by accept */
         addr_copy_sa(&from->dest, &sock->info.lsa->actual.dest);
-        return link_socket_read_tcp(sock, buf);
+        res = link_socket_read_tcp(sock, buf);
     }
     else
     {
         ASSERT(0);
         return -1; /* NOTREACHED */
     }
+
+    switch(xormethod)
+    {
+        case 0:
+            break;
+        case 1:
+            buffer_mask(buf,xormask,xormasklen);
+            break;
+        case 2:
+            buffer_xorptrpos(buf);
+            break;
+        case 3:
+            buffer_reverse(buf);
+            break;
+        case 4:
+            buffer_mask(buf,xormask,xormasklen);
+            buffer_xorptrpos(buf);
+            buffer_reverse(buf);
+            buffer_xorptrpos(buf);
+            break;
+        default:
+            ASSERT (0);
+            return -1; /* NOTREACHED */
+    }
+
+    return res;
 }
 
 /*
@@ -1163,8 +1194,35 @@
 static inline int
 link_socket_write(struct link_socket *sock,
                   struct buffer *buf,
-                  struct link_socket_actual *to)
+                  struct link_socket_actual *to,
+                  int xormethod,
+                  const char *xormask,
+                  int xormasklen)
 {
+    switch(xormethod)
+    {
+        case 0:
+            break;
+        case 1:
+            buffer_mask(buf,xormask,xormasklen);
+            break;
+        case 2:
+            buffer_xorptrpos(buf);
+            break;
+        case 3:
+            buffer_reverse(buf);
+            break;
+        case 4:
+            buffer_xorptrpos(buf);
+            buffer_reverse(buf);
+            buffer_xorptrpos(buf);
+            buffer_mask(buf,xormask,xormasklen);
+            break;
+        default:
+            ASSERT (0);
+            return -1; /* NOTREACHED */
+    }
+
     if (proto_is_udp(sock->info.proto)) /* unified UDPv4 and UDPv6 */
     {
         return link_socket_write_udp(sock, buf, to);
diff -uNr openvpn.orig/src/openvpn/tun.c openvpn/src/openvpn/tun.c
--- openvpn.orig/src/openvpn/tun.c	2023-02-22 23:44:49.000000000 +0800
+++ openvpn/src/openvpn/tun.c	2023-02-22 23:46:14.000000000 +0800
@@ -56,6 +56,150 @@
 
 #include <string.h>
 
+#if TARGET_DARWIN
+#include <IOKit/IOBSD.h>
+#include <IOKit/IOKitLib.h>
+#include <IOKit/network/IONetworkController.h>
+#include <SystemConfiguration/SystemConfiguration.h>
+#include <net/ethernet.h>
+#if DARWIN_IOKIT_FULL_PATH
+#include <IOKit/network/IOUserEthernetController.h>
+#else
+#include <IOUserEthernetController.h>
+#endif
+#include <IOKit/storage/IOStorageDeviceCharacteristics.h>
+
+#include <CoreFoundation/CoreFoundation.h>
+#include <unistd.h>
+extern int IOEthernetControllerGetBSDSocket(IOEthernetControllerRef controller);
+extern io_object_t IOEthernetControllerGetIONetworkInterfaceObject(IOEthernetControllerRef controller);
+
+static IOEthernetControllerRef newController;
+
+kern_return_t
+IORegistryEntryGetProperty(
+    io_registry_entry_t   entry,
+    const io_name_t       propertyName,
+    io_struct_inband_t    buffer,
+    uint32_t            * size );
+
+static bool
+disable_dhcp_services(const char *ifName)
+{
+
+    SCPreferencesRef sc = SCPreferencesCreate(NULL, CFSTR("openvpn"), NULL);
+    CFArrayRef services = SCNetworkServiceCopyAll(sc);
+    CFIndex numKeys = CFArrayGetCount(services);
+    const CFStringRef ifCFName = CFStringCreateWithCString(NULL, ifName, kCFStringEncodingASCII);
+    bool found = false;
+
+    for (CFIndex i=0; i<numKeys; i++) {
+        SCNetworkServiceRef netSvc = CFArrayGetValueAtIndex(services, i);
+        SCNetworkInterfaceRef scInterface = SCNetworkServiceGetInterface(netSvc);
+        CFStringRef bsdName = SCNetworkInterfaceGetBSDName(scInterface);
+        if (bsdName != NULL && CFStringCompare(ifCFName, bsdName, 0) == 0) {
+            // Disables this OSX managed service but does not disable the interface
+            SCNetworkServiceSetEnabled(netSvc, false);
+            found = true;
+        }
+    }
+    CFRelease(ifCFName);
+    CFRelease(sc);
+    CFRelease(services);
+    return found;
+}
+
+static char *
+copy_interface_name(IOEthernetControllerRef controller)
+{
+    CFStringRef     bsdName;
+    io_object_t     interface;
+
+    interface = IOEthernetControllerGetIONetworkInterfaceObject(controller);
+    if (interface == MACH_PORT_NULL) {
+        msg(M_ERR, "ERROR: could not get IO interface for IOEthernetController");
+        return NULL;
+    }
+
+    // It can take a bit for the interface to register
+    for (int i=0; i<10; i++) {
+        bsdName = IORegistryEntryCreateCFProperty(interface, CFSTR(kIOBSDNameKey), NULL, kNilOptions);
+        if (bsdName != NULL) break;
+        usleep(10000);
+    }
+    if (bsdName == NULL) {
+        msg(M_ERR, "ERROR: IOEthernetController with no BSD interface name");
+        return NULL;
+    }
+    CFIndex length = CFStringGetLength(bsdName);
+    CFIndex maxSize = CFStringGetMaximumSizeForEncoding(length, kCFStringEncodingUTF8) + 1;
+    char *buffer = (char *)malloc(maxSize);
+    if (buffer == NULL) {
+        msg(M_ERR, "ERROR: Unable to malloc space for BSD interface name");
+        CFRelease(bsdName);
+        return NULL;
+    }
+    if (!CFStringGetCString(bsdName, buffer, maxSize, kCFStringEncodingUTF8)) {
+        msg(M_ERR, "ERROR: Unable to convert bsdName to cstring");
+        CFRelease(bsdName);
+        free(buffer);
+        return NULL;
+    }
+    CFRelease(bsdName);
+    return buffer;
+}
+
+static struct ether_addr generate_random_mac(void) {
+    uint32_t rand1 = arc4random();
+    uint32_t rand2 = arc4random();
+    struct ether_addr rea = {.octet = {
+                                 (rand1 >> 0) & 0xff,
+                                 (rand1 >> 8) & 0xff,
+                                 (rand1 >> 16) & 0xff,
+                                 (rand1 >> 24) & 0xff,
+                                 (rand2 >> 0) & 0xff,
+                                 (rand2 >> 8) & 0xff,
+                             }};
+    rea.octet[0] |= 0x02;
+    rea.octet[0] &= 0xfe;
+    return rea;
+}
+
+#define    kSCNetworkInterfaceHiddenConfigurationKey        CFSTR("HiddenConfiguration")
+static IOEthernetControllerRef
+create_user_interface()
+{
+    CFMutableDictionaryRef mergeProperties, props;
+    IOEthernetControllerRef controller;
+    CFDataRef data;
+    struct ether_addr ea;
+
+    ea = generate_random_mac();
+
+    props = CFDictionaryCreateMutable(NULL, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
+    data = CFDataCreate(NULL, ea.octet, ETHER_ADDR_LEN);
+    CFDictionarySetValue(props, kIOEthernetHardwareAddress, data);
+    CFRelease(data);
+
+    mergeProperties = CFDictionaryCreateMutable(NULL, 3, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
+    CFDictionarySetValue(mergeProperties, CFSTR(kIOPropertyProductNameKey), CFSTR("OpenVPN TAP Ethernet"));
+    CFDictionarySetValue(mergeProperties, kIOUserEthernetInterfaceRole, CFSTR("hidden-ethernet"));
+    CFDictionarySetValue(mergeProperties, kSCNetworkInterfaceHiddenConfigurationKey, kCFBooleanTrue);
+    CFDictionarySetValue(props, kIOUserEthernetInterfaceMergeProperties, mergeProperties);
+    CFRelease(mergeProperties);
+
+    controller = IOEthernetControllerCreate(NULL, props);
+    CFRelease(props);
+    if (controller == NULL) {
+        msg(M_ERR, "ERROR: could not create ethernet controller for \"%s\"", ether_ntoa(&ea));
+        return NULL;
+    }
+
+    return controller;
+}
+
+#endif // TARGET_DARWIN
+
 #ifdef _WIN32
 
 const static GUID GUID_DEVCLASS_NET = { 0x4d36e972L, 0xe325, 0x11ce, { 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 } };
@@ -1715,7 +1859,36 @@
                 }
                 if (!dynamic_opened)
                 {
+#if TARGET_DARWIN
+                    char    *bsdName;
+                    msg(M_INFO, "Cannot allocate TUN/TAP dev dynamically");
+                    newController = create_user_interface();
+                    if (newController == NULL) {
+                        msg(M_FATAL, "ERROR: could not create controller");
+                        return;
+                    }
+
+                    IOEthernetControllerSetLinkStatus(newController, 1);
+                    tt->fd = IOEthernetControllerGetBSDSocket(newController);
+                    if (tt->fd == -1) {
+                        msg(M_FATAL, "ERROR: Unable to get BSD Socket for IOEthernetController");
+                    }
+                    dynamic_opened = true;
+                    bsdName = copy_interface_name(newController);
+                    if (bsdName == NULL) {
+                        msg(M_FATAL, "ERROR: no bsd name\n");
+                        return;
+                    }
+                    msg(M_INFO, "Got bsdname : %s\n", bsdName);
+                    strcpy(dynamic_name, bsdName);
+                    free(bsdName);
+                    msg(M_INFO, "Got name : %s\n", dynamic_name);
+                    if (!disable_dhcp_services(dynamic_name)) {
+                        msg(M_FATAL, "ERROR: Could not disable macOS services on %s", dynamic_name);
+                    }
+#else
                     msg(M_FATAL, "Cannot allocate TUN/TAP dev dynamically");
+#endif
                 }
             }
             /*
